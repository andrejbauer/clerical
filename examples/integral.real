function prec(int x):
  1.0 /. real(shift(1, x))

function abs(real x):
  lim n =>
    case
      x <. prec (n + 1) => real (0) -. x
    | x >. real (0) -. prec (n + 1) => x
    end

function bound(real x, real d):
  case
    abs(x) <. d => true
  | abs(x) >. d /. real(2) => false
  end

function nbound(real x, real d):
  if bound(x, d) then false else true end



function sin (real x):
  lim p =>
    var epsilon := prec(p)
    and m := 0
    and s := real(1)
    and A := real(0)
    and q := x in
    while nbound (q, epsilon)
    do
      m := m + 1;
      A := A +. q *. s;
      s := s *. real(-1);
      q := q *. x *. x /. real(2 * m + 1) /. real(2 * m)
    end; A

function pow(real x, int n):
  var p := 1.0 and
  i := 0 in
  while i < n do
    p := p *. x;
    i := i + 1
  end;
  p

function e (real x):
  lim n =>
    let err = shift(1, n) in
    var i := 1
    and e := 0.0
    and f := 1
    and rerr := real(err) in
    while bound(real(f) /. pow(x, i - 1), rerr) do
    (*while real(f) /. pow(x, i - 1)<. real(err) do*)
      e := e +. pow(x, i - 1) /. real(f) ;
      f := f * i ;
      i := i + 1
    end ;
    e

function pi ():
  lim n =>
    var k := 0
    and a := real(3)
    and b := real(4) in
    while k < n
    do
      var x := (a +. b) /. real(2) in
      if
        real (0) <. sin (x)
      then
        a := x
      else
        b := x
      end
      ;
      k := k + 1
    end; (a +. b) /. real(2)


function square(real x, real c):
  x *. x -. c

function sqrt (real a, real b, real c):
  lim n =>
    var k := 0
    and a := a
    and b := b in
    while k < n * int(b -. a)
    do
      var x := (a +. b) /. real(2) in
      if
        real (0) <. square (x, c)
      then
        b := x
      else
        a := x
      end
      ;
      k := k + 1
    end; (a +. b) /. real(2)

function sum (int prec):
  trace;
  let rprec = real(prec) in
  var a := (array [prec] i => let ri = real(i) in 1.0 /. e(((ri +. 0.5) *. (ri +. 0.5))/. rprec /. rprec /. 2.0))
  and sum := 0.0
  and i := 0 in
  while i < prec do
    sum := sum +. a[i];
    i := i + 1
  end;
  sum /. real(prec)

function integral ():
  lim n =>
    var a := real(0)
    and b := real(1)
    and prec := shift(1, n) in
    sum(prec)


function demo ():
  plet i = integral ()
  and pi = pi () in
  let s = sqrt(1.0, 10.0, 2.0 *. pi) in
  i /. s
